# Available options for configuring this library. Do not edit this file,
# instead define vars in the top-level makefile of the application that links
# against this library.

# Enable a watchdog timer to issue a reset on hang
#    Currently watchdog is never kicked, so reset is unconditional.
CONFIG_WATCHDOG ?= 0

# Enable a time-keeping timer (systick)
CONFIG_SYSTICK ?= 0

# Maintain 32-bit system time (systick)
# 		Handle overflow in system timer and increment a 32-bit timestamp.
CONFIG_SYSTICK_32BIT ?= 0

# Enable functionality for manipulating charge on target capacitor
CONFIG_CHARGE_MANIP ?= 0

# Enable a GPIO pin that controls the power supply to the target
CONFIG_TARGET_POWER_SWITCH ?= 0

# Enable handling of watchpoint (streaming to host and/or collecting a profile)
CONFIG_ENABLE_WATCHPOINTS ?= 0

# Enable this many consecutive watchpoints automatically when EDB starts
CONFIG_AUTO_ENABLED_WATCHPOINTS ?=

# Enable breakpoints stored on the target-side
# 		The number of such breakpoints is not limited by the number of
# 		codepoints pins. The downside is that to enable a passive breakpoint,
# 		the target must be interrupted first to enter interactive debugging
# 		mode and run the enable command in the console.
CONFIG_ENABLE_PASSIVE_BREAKPOINTS ?= 0

# Enable feature to deliver watchpoint events to host via 'stream' cmd
CONFIG_ENABLE_WATCHPOINT_STREAM ?= 0

# Support entering and exiting active debug mode
# 		   The reason we have a switch are the limited resources
#          on the MCU that need to be shared (specifically, timers).
#          Right now, RFID TX decoding and debug mode cannot
#          co-exist.
CONFIG_ENABLE_DEBUG_MODE ?= 0

# Support requests to enter debug mode initiated by the target
CONFIG_ENABLE_TARGET_SIDE_DEBUG_MODE ?= 0

# Power target in debug mode
CONFIG_POWER_TARGET_IN_DEBUG_MODE ?= 0

# Fetch interrupt context from target
CONFIG_FETCH_INTERRUPT_CONTEXT ?= 0

# Have a time out for entering and exiting debug mode (reset state machine on timeout)
CONFIG_ENABLE_DEBUG_MODE_TIMEOUTS ?= 0

# Reset debug mode state machine when target detected to turn on
# 			The detection is done by monitoring Vreg rising to MCU_ON_THRES
#           using the comparator.
#
#           This conflicts with other uses of the comparator: charge, discharge,
#           and energy breakpoint. All of these have alternative implementations
#           using the ADC.
#
#           TODO: this should be enablable at runtime using a console command
#           	  from the host and persisted in an option dictionary (not
#           	  implemented)
CONFIG_RESET_STATE_ON_BOOT ?= 0

# Enable streaming voltages
# 		Requires a timer to be allocated for the ADC trigger (see
# 		TMRMOD_ADC_TRIGGER).
CONFIG_ENABLE_VOLTAGE_STREAM ?= 0

# Abort if a fault in the UART module is detected
# 		Indication: red led on, and iff error is overflow, then green led blinking.
CONFIG_ABORT_ON_HOST_UART_ERROR ?= 0

# Abort if RFID event buffer overflows (as opposed to dropping events)
CONFIG_ABORT_ON_RFID_EVENT_OVERFLOW ?= 0

# Capacitor charge implemented by a PWM with a control loop around the duty-cycle
# 		The alternative is an "valve" method of raising a GPIO high and watching
#       the voltage level with ADC or comparator and pulling the GPIO low once
#       the target threshold is crossed.
CONFIG_PWM_CHARGING ?= 0

# Enable pull-down on the debugger<->target communication lines.
#
# 		  We watch for interrupts the target raises when the target requests
#         to enter active debug mode, such as upon hitting an internal or
#         external breakpoint. If the target is off or not present, then both
#         ends of this line are in high impedence mode (effectively
#         floating?). This does not seem to cause spurious interrupts, but if
#         this problem did arise, enabling pull-down resistors should solve
#         it.
#
#         Also, when using watchpoints, unconnected lines (at least on
#         dev boards) may float high without the pull-down.
#
#         NOTE: The pull-down causes energy interference (current is sourced
#         from the target when target drives this pin high), but the target
#         only drives this pin high for at most one cycle (signal
#         communication is exclusively done using one-cycle-long pulses).
#
CONFIG_PULL_DOWN_ON_COMM_LINES ?= 0

# Enable communication to target device via a UART module
CONFIG_TARGET_UART ?= 0

# Let target send EDB messages without EDB having issued a request
#      This is for STDIO output for example.
CONFIG_TARGET_UART_PUSH ?= 0

# Enable communication to host workstation via a UART module
CONFIG_HOST_UART ?= 0

# Enable code for decoding the RF protocol
# 		Currently, this is disabled because it causes spurious interrupts.
#
#       TODO: setup RF pins only upon cmd to monitor RF because otherwise we
#       get spurious interrupts on RX pin
CONFIG_ENABLE_RF_PROTOCOL_MONITORING ?= 0

# Decode the RFID command payload bits (not only the command code)
# 	TODO: NOT IMPLEMENTED
CONFIG_DECODE_RFID_CMD_PAYLOAD ?= 0

# When parsing RFID messages, use calculated bounds on symbol duration
#   For some symbols, their duration depends on the duration of
#   previous symbols (e.g. some symbol durations are defined in
#   terms of Tari symbol duration). This flag turns on implementation
#   of symbol time validity checks using such dynamic bounds
#   calculated at runtime.  This is a true implementation of the
#   spec, as opposed to static magic bounds chosen by trial and error
#   in a particular setup, However this is expensive in terms of
#   cycles (too expensive to work?).
CONFIG_RFID_DECODER_RUNTIME_BOUNDS ?= 0

# Enable listening and recording communication on I2C bus
# 		TODO: this is not currently implemented
CONFIG_ENABLE_I2C_MONITORING ?= 0

# Route serial decoder events to external pins
# 		For testing and tuning decoding of serial protocol over the signal
# 		line.
CONFIG_SIG_SERIAL_DECODE_PINS ?= 0

# Enable an auxiliary signal useful for triggering a scope
# 		A pulse is issued when a host command is ready for execution.
CONFIG_SCOPE_TRIGGER_SIGNAL ?= 0

# Encode debugger state machine state onto pins
CONFIG_STATE_PINS ?= 0

# Enable pins for general-purpose event reporting (for debugging)
CONFIG_EVENT_PINS ?= 0

# Encode RFID decoder state onto pins for debugging purposes
CONFIG_RFID_DECODER_STATE_PINS ?= 0

# TODO: convert into a bitmask with all LEDs

# Blink an LED on boot
CONFIG_BOOT_LED ?= 0

# Blink an LED in the main loop
CONFIG_MAIN_LOOP_LED ?= 0

# Turn on an LED when in debug mode
CONFIG_DEBUG_MODE_LED ?= 0

# Turn on an LED when errors are encountered
CONFIG_ERROR_LED ?= 0

# Enable debug output to the console configured from the top-level app makefile
CONFIG_DEV_CONSOLE ?= 0

# Enable setting a callback function that will be called on each watchpoint
CONFIG_ENABLE_WATCHPOINT_CALLBACK ?= 0
