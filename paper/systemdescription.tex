\sys is a new programming and execution model for intermittent computing on energy-harvesting devices. \sys addresses the challenges outlined in Section~\ref{sec:background} to make task-based intermittent programs {\em programmable} and {\em efficient}. \sys accomplishes this goal with a constellation of a new programming model and run time software system support, that supports dynamically adaptive task-based execution. Figure~\ref{fig:system_overview} shows an overview of \sys.

\begin{wrapfigure}{t!}{0.5\textwidth}
	\centering
	\includegraphics[width=0.5\columnwidth]{figures/graffle/overview.pdf}
	\caption{\sys top-level view. \textcolor{red}{redraw the figure: change font type}}
	\label{fig:system_overview}
\end{wrapfigure}

\textbf{\sys Programming and Execution Model.}  To use \sys, a programmer first writes plain, imperative C code. The programmer then must decompose the program into tasks. To manually decompose a program into tasks, the programmer designates a set of functions as tasks, sequences control-flow between these tasks, and annotates memory accesses that manipulate data shared by multiple tasks. In other words, it requires reasoning similar to prior task-based systems~\cite{chain,alpaca}. 

A programmer may also opt to use compiler support to automatically decompose a program into tasks, leveraging recent work~\cite{cleancut_2018,baghsorkhi_cgo_2018}. Without loss of generality, we assume throughout this work that the programmer manually decomposed the program into tasks; \sys's behavior with automatically decomposed code would be identical.

The programmer compiles their task-based code, and links to the \sys runtime, producing a \sys-enabled binary. The \sys runtime implements \sys's task-based programming and execution model. The runtime system also includes \sys's novel {\em virtualizing memory manager} and its {\em task coalescing manager}, and {\em task downscaling manager}, both of which are essential to \sys's adaptive task-based execution.

\textbf{\sys Task Coalescing Manager.} \sys relies on its task coalescing manager to dynamically {\em coalesce} statically\hyp{}defined tasks to avoid inessential overheads associated with completing tasks. By default, tasks run in a sequence and each task commits its task-shared state as it completes.  The time and energy cost of a task's commit is unnecessary if the task and its successor both complete without a power failure. The key insight that \sys leverages is that the first task could have deferred its commit to the second task. {\em coalescing} tasks by deferring the first commit avoids the fixed cost of the first commit (task transitioning overheads). Coalescing also amortizes per-variable commit cost, committing each location accessed by both tasks only after the second task, rather than once per task. \textcolor{red}{\sys's coalescing manager is an \emph{energy-aware manager}. It uses the recent execution history---pure software technique---as a metric to estimate the amount of the available energy and to set the adequate coalesced task size accordingly. This fundamental feature prevents \sys from blind coalesced task adaptation which can result in a repeated power failures problem. For example, If \sys enlarges the coalesced task size by $x$ static tasks on a coalesced task completion and reduces it by the same number of static tasks on a power reboot, then \sys may need to reboot, for instance, 10 times to reduce a coalesced task size from 10 to one, when $x=1$}


Details of coalescing are presented in Section~\ref{sec:task_coalescing}.

\textbf{\sys Task Downscaling Manager.} \sys's downscaling manager is responsible for preserving the forward progress when \sys fails repeatedly on a single static task. The downscaling manager utilizes a timer-based technique to split a big task and ensure a partial progress. 

 Details of task downscaling are presented in Section~\ref{sec:task_downsizing}. \textcolor{red}{to be written}
 
 \textcolor{red}{Why hardware based checkpoint systems are static? and why \sys's partial commit is dynamic?}

\textcolor{red}{(i) Stopping at arbitrary locations in the code may result in incorrect computation or even crash the program. If a system checkpoints between, for example, the DMA initialization and the DMA call the program will crash. One might think that a simple solution is to disable interrupts at these critical regions. Although this is the correct solution, the checkpoint-based system will "theoretically" stuck (non-termination problem) because it has to checkpoint at this exact location since it is a threshold-based system, so it is a static system. However, \sys's partial commit is not threshold based therefore it allows the programmer to disable interrupts at certain locations and it will partially commit around it.}

\textcolor{red}{(ii) A Checkpoint system normally checkpoints all volatile data. Therefore, it suffers from moving large amount of data on each checkpoint. However, \sys's partial commit technique relies on a paging mechanism, which makes the size of the commit proportional to the number of state-less instructions executed. In other words, if energy allows executing only a small chunk of code, the amount of data to be committed shrinks accordingly. As such, \sys's execution model is neither limited by a static task size to progress, nor by the commit size,
}

\textbf{\sys Virtual Memory Manager.} \sys is able to efficiently coalesce tasks because of its efficient virtual memory manager, which is described in Section~\ref{sec:memory_virtualization}. \sys's memory manager paginates memory and ensures that data in a page remain consistent despite power interruptions. \sys allows a task to manipulate data in a volatile copy of a page only. Pages swap between volatile and non-volatile memory, depending on the capacity of the volatile memory and the program's access pattern. \sys tracks a task's memory accesses efficiently at page granularity (rather than using, e.g., costly word-granular tracking). When a task ends, each page it accessed commits from volatile memory (or from a non-volatile swap region for dirty pages) back to the non-volatile main memory. Pages efficiently, atomically commit using a two-phase commit procedure accelerated using hardware support for direct memory access (DMA). Details of Virtual Memory Manager are presented in Section~\ref{sec:memory_virtulaization}.