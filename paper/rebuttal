We thank the Reviewers for assessing our paper. Our responses to all
questions are itemized and given below.

> Comparison with checkpointing-based approaches

We focused our comparison on task-based systems (Chain [10]), which were shown
to perform better than checkpointing-based systems. We appreciate the
suggestion to extend the comparison and reproduce this prior result.

> Why do statically placed task boundaries underestimate the task size?

At compile time, the compiler has to generate small tasks that can execute when
input energy is as low as possible, with the smallest energy reservoir. Coala
coalesces the (small, inefficient) static tasks at runtime, in response to
available energy.

> Why only one page in volatile memory and how Figure 10 evaluates its size?

A single-page buffer allows very fast translation implementable in software,
without any HW support (in form of an MMU). In Figure 10 we vary the size of
the page, while keeping it below the fixed size of the volatile memory on the
MCU. Varying the size of the volatile buffer (for protected variables) is not
the same as varying the size of volatile memory, because volatile memory is
also used by all unprotected variables.

In Figure 10, "cuckoo" and "bc" have zero page faults, and we will
improve the presentation of the data to make this clear.

> Significance of PagesTemp in virtualization: 

PagesTemp is the non-volatile page buffer necessary to implement the two-phase
atomic commit (Section 5.1.3).  The first phase of the commit writes pages to
PagesTemp and the second phase writes the pages from PagesTemp into their
locations in main non-volatile memory. Without the PagesTemp buffer, atomicity
(i.e. either all dirty pages are modified or none are) cannot be guaranteed in
the face of unpredictable power failures.

> Can Coala encounter a live-lock during commit?

When pages are copied from PagesTemp in the second-phase of the commit, once
each page finishes copying, it's dirty bit is cleared, and it will not be
re-copied again. If power fails before the last page is copied, the
second-phase will restart, but it will resume copying only uncopied pagies.
We will explain in Section 5, that since the amount of work in the second-phase
of the commit decreases with each attempt, the live-lock cannot occur as long
as there is sufficient energy to copy one page.

> Memory and register alignment (consistency) across coalesced tasks 

Task code does not change as a result of coalescing: tasks remain
self-contained idempotent regions of code -- values in registers do not remain
live across a task boundary, regardless of whether the boundary is coalesced at
runtime or not.

> Language-level restrictions imposed by Coala 

In Section 4, we state that Coala does not support recursion, must be able to
ensure a single entry into each task (which precludes goto-like primitives). In
4.1.1, we explain how Coala handles loops without a static bound (a boundary is
placed in the loop body). We will add to section 4.1 that our analysis does not
support function pointers. We appreciate the suggestion to define the supported
language subset explicitly.

> CFG compiler analysis and inlining 

In Section 4.1 we list the drawbacks of inlining, and suggest an alternative
potential approach that places a boundary on each function invocation. 

> Commit implementation alternatives and relationship to databases/filesystems: 

Section 8 explains the relationship to transactional memory and shadow-paging.
We appreciate the suggestions for exploring more implementation of commit and
comparing them to the implementation that we chose for Coala.

> Amount of coalescing in the experiments: 

Our measurement setup (Section 7.1) did not include an ability to trace the
coalescing that took place at runtime during the experiment in Figure 8.
Tracing while running on intermittent power is difficult due to the lack of any
channel for debug information out of the device. Figure 8 shows the end-to-end
effect of coalascing: the time application took to complete.

> Compilation time and memory

We list the compilation time taken by the Coala compiler on each benchmark in
Table 3.  Section 7.2.2 mentions that 1GB of RAM (in a VM) was sufficient for
the compiler.

> Relevance of benchmarks to IoT and embedded applications: 

Our benchmarks (Section 7.1) range from end-to-end applications that acquire
and process sensor data, e.g. Cold-chain Equipment Monitoring to computations
relevant to an embedded sensing device (DFT, encryption, compression, sorting),
similar to ones in established suites (e.g. MiBench).


-----
> Modesty of contribution

We believe that our work opens a new research area in intermittent computing -
on-the-fly task adaptability - which is beyond the modesty of the contribution.
-----
