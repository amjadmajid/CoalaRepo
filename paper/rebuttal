We thank the Reviewers for assessing our paper. Our responses to all questions are itemized and given below.

**Comparison with checkpointing-based approaches:** We focused our comparison on task-based systems (Chain [10]), which prior work showed perform better than some checkpointing-based systems. We appreciate the suggestion to extend our evaluation to include more prior results.

**Why do statically placed task boundaries underestimate the task size:** At compile time, the compiler has to generate small tasks that can execute with little energy available (i.e., with a small energy buffer and negligible input power). Coala coalesces small tasks at runtime, adapting to available energy.

**Why only one page in volatile memory and how Figure 10 evaluates its size:** A single-page buffer allows for fast software translation without an MMU. In Figure 10 we vary the size of the page, while keeping it below the fixed size of the volatile memory on the MCU. 

In Figure 10, "cuckoo" and "bc" have zero page faults, and we will improve the
presentation of the data to make this clear.

**Significance of PagesTemp in virtualization:** PagesTemp is a non-volatile page commit buffer that we use for two-phase commit (Section 5.1.3).  The execution phase ends and writes dirty pages to PagesTemp, and the commit phase atomically (regardless of power interruption) writes pages from PagesTemp into their locations in non-volatile main memory.

**Can Coala encounter a live-lock during commit:** When pages are copied from PagesTemp in the second-phase of the commit, once each page finishes copying, it's dirty bit is cleared, and it will not be re-copied again. If power fails before the last page is copied, the second-phase will restart, but it will resume copying only un-copied pages.  We will explain in Section 5, that since the amount of work in the second-phase of the commit decreases with each attempt, the live-lock cannot occur as long as there is sufficient energy to copy one page.

**Memory and register alignment (consistency) across coalesced tasks:** Task code does not change as a result of coalescing: tasks remain self-contained idempotent regions of code -- registers do not live across a task boundary, regardless of coalescing.

**Language-level restrictions imposed by Coala:** In Section 4, we state that Coala does not support recursion, must be able to ensure a single entry into each task (which precludes goto and similar primitives). In 4.1.1, we explain how Coala handles loops without a static bound (a boundary is placed in the loop body). We will add to section 4.1 that our analysis does not support function pointers. 

**CFG compiler analysis and inlining:** In Section 4.1 we list the drawbacks of inlining, and suggest an alternative potential approach that places a boundary on each function invocation. 

**Commit implementation alternatives and relationship to databases/filesystems:** Section 8 explains the relationship to transactional memory and shadow-paging. We appreciate the suggestion to compare to more implementation alternatives. 

**Amount of coalescing in the experiments:** Our measurement setup (Section 7.1) did not include an ability to trace the coalescing that took place at runtime during the experiment in Figure 8. Tracing while running on intermittent power is difficult due to the lack of any channel for debug information out of the device. Figure 8 shows run time, which captures the end-to-end effect of coalascing.

**Compilation time and memory:** We list the compilation time taken by the Coala compiler on each benchmark in Table 3.  Section 7.2.2 mentions that 1GB of RAM (in a VM) was sufficient for the compiler.

**Relevance of benchmarks to IoT and embedded applications:** Our benchmarks (Section 7.1) include both end-to-end applications that acquire and process sensor data and computational kernels relevant to embedded sensing devices (DFT, encryption, compression, sorting), similar to ones in established suites (e.g. MiBench).