\documentclass[sigconf,anonymous,review]{acmart}

\usepackage[normalem]{ulem}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm} % environment for the algorithm code (like figure and table)
\usepackage{algorithmicx} % write the pseudo code
\usepackage[noend]{algpseudocode} % layout of the pseudo code
\usepackage{tikz} % needed for: tikz pics
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{subfigure}
%\usepackage[inline]{enumitem}

\newcommand{\TODO}[1]{{\bf \em \textcolor{red}{TODO: #1}\xspace}}

\newcommand{\todo}[2]{\textcolor{red}{$\bullet$ \textbf{Task:} #1; \textbf{Responsible:} #2}}

\newcommand{\sys}{VIPRE\xspace}
\newcommand{\sysfull}{Virtualized Intermittently-Powered Runtime Environment\xspace}

\setcopyright{rightsretained}

\acmDOI{http://dx.doi.org/xx.xxxx/xxxxxxx.xxxxxxx}

\acmISBN{978-1-xxxx-xxxx-x/17/11}

\acmConference[ASPLOS]{The 23rd ACM International Conference on Architectural Support for Programming Languages and Operating Systems}{March 24--28, 2017}{Williamsburg, VA, USA}

\acmYear{2017}

\copyrightyear{2017}

\acmPrice{15.00}

\begin{document}

\title[VIPRE: Virtualized Intermittently-Powered Runtime Environment]{VIPRE: Virtualized Intermittently-Powered Runtime Environment}

%Note: order of authors placed randomly

\author{Kiwan Maeng}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Carnegie Mellon University}
	\streetaddress{4720 Forbes Avenue}
	\city{Pittsburgh} 
	\state{PA} 
	\postcode{15213}
}
\email{kmaeng@andrew.cmu.edu}

\author{Alexei Colin}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Carnegie Mellon University}
	\streetaddress{4720 Forbes Avenue}
	\city{Pittsburgh} 
	\state{PA} 
	\postcode{15213}
}
\email{acolin@andrew.cmu.edu}

\author{Brandon Lucia}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Carnegie Mellon University}
	\streetaddress{4720 Forbes Avenue}
	\city{Pittsburgh} 
	\state{PA} 
	\postcode{15213}
}
\email{blucia@andrew.cmu.edu}

\author{Amjad Yousef Majid}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Delft University of Technology}
	\streetaddress{Mekelweg 4}
	\city{Delft, The Netherlands} 
	\state{Zuid Holland} 
	\postcode{2628\,CD}
}
\email{a.y.majid@tudelft.nl}

\author{Kas{\i}m Sinan Y{\i}ld{\i}r{\i}m}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Delft University of Technology}
	\streetaddress{Mekelweg 4}
	\city{Delft, The Netherlands} 
	\state{Zuid Holland} 
	\postcode{2628\,CD}
}
\email{k.s.yildirim@tudelft.nl}

\author{Przemys{\l}aw Pawe{\l}czak}
%\authornote{}
%\orcid{}
\affiliation{%
	\institution{Delft University of Technology}
	\streetaddress{Mekelweg 4}
	\city{Delft, The Netherlands} 
	\state{Zuid Holland} 
	\postcode{2628\,CD}
}
\email{p.pawelczak@tudelft.nl}

\renewcommand{\shortauthors}{A. Y. Majid et al.}

\begin{abstract}
\input{abstract}
\end{abstract}

% The code below should be generated by the tool at 
%http://dl.acm.org/ccs.cfm Please copy and paste the code instead of the 
%example below. 

\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10010520.10010553.10010562.10010564</concept_id>
	<concept_desc>Computer systems organization~Embedded 
	software</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	<concept>
	<concept_id>10010520.10010575.10010578</concept_id>
	<concept_desc>Computer systems organization~Availability</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	<concept>
	<concept_id>10011007.10010940.10010941.10010949.10010957.10010688</concept_id>
	<concept_desc>Software and its engineering~Scheduling</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	<concept>
	<concept_id>10011007.10010940.10010941.10010949.10010965</concept_id>
	<concept_desc>Software and its engineering~Communications 
	management</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	<concept>
	<concept_id>10011007.10010940.10010971.10010564</concept_id>
	<concept_desc>Software and its engineering~Embedded 
	software</concept_desc>
	<concept_significance>300</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded software}
\ccsdesc[300]{Computer systems organization~Availability}
\ccsdesc[300]{Software and its engineering~Scheduling}
\ccsdesc[300]{Software and its engineering~Communications management}
\ccsdesc[300]{Software and its engineering~Embedded software}

\keywords{Energy harvesting, transient operation, operating system}

\maketitle

\section{Introduction}
\label{sec:intro}

%\TODO{VIPER: Virtualised Intermittent Programming model, Execution model, and Runtime environment}
%\TODO{PREVIEW: Programming and Runtime Environment with Virtualised Intermittent Execution Windows}

\input{intro}

\section{Computation on Intermittent Devices: Background}
\label{sec:background}

Performing complex operations on battery-less energy harvesting embedded platforms is challenging from many points of view. Here we shall briefly provide a background on computation with energy harvesting embedded systems. 

\subsection{Energy Harvesting: Background}

Supplying power to tiny embedded computers using batteries alone is not sustainable. Batteries are a great pollutant. A solution is to replace batteries with smaller, but more environment friendly capacitors and supply power directly from the ambient energy sources. 

What platforms enable intermittent computation: WISP~\cite{} (with its variants such as WISPCam~\cite{}), Moo~\cite{}, ambient backscatter~\cite{}, or computation RFID commercial platforms such as~\cite{}. In case of the above platforms, the main source of energy is electromagnetic radiation in the radio frequency range.

Application include long-term battery-less monitoring. One example is the distributed monitoring of moisture of large plant fields during vegetation~\cite{}. Other applications include battery-less image capture and processing~\cite{}, distributed low-power networking~\cite{}.

Energy provided from the ambient is not stable and difficult to predict accurately. Combined with the fact that energy supply is small, there is little leeway to store enough of energy to guarantee prolonged periods of computation. Energy breaks happen every hundred of ms~\cite{}.

Solution to the problem is to divide the program into smaller pieces that guarantee execution within a discharge region and track the state of the program in-between the program part execution times. 

\subsection{(Task-based) Intermittent Computing: Background}

\begin{figure}
	\centering
	%\includegraphics[width=0.25\columnwidth]{figures/}
	\caption{Two problems with fixed-size task in intermittent execution. (a) task underestimation: task executed at device with capacitor size $X$, will not execute at device with capacitor $X\gg Y$; (b) task overestimation: with stable energy source task tracking causes unnecessary overhead.}
	\label{fig:fixed_task_problem}
\end{figure}

Various capacitor sizes of intermittent device result in a program being executed 

Other forms of intermittent platforms will share the same problem. One of them considers actuation platforms, which will be powered directly from energy harvesting sources~\cite{}. will share the energy storage with computing platform. However, power supply for actuators is order of magnitude larger than for computation. Therefore, although capacitor is large enough to perform computation alone, energy to power actuators takes precedence leaving not much space for computing.


\TODO{Elaborate on the ``key challenge'' paragraphs near the end of the intro.}

\section{\sysfull}
\label{sec:overeall_system}

\begin{figure}
	\centering
	%\includegraphics[width=0.25\columnwidth]{figures/}
	\caption{\sys top-level description.}
	\label{fig:}
\end{figure}

Describe the overall system, the programming model, and the semantics/execution model. This should include a discussion of memory virtualization and task coalescing.

\section{Memory Virtualization}
\label{sec:memory_virtulaization}

\begin{figure}
	\centering
	%\includegraphics[width=0.25\columnwidth]{figures/}
	\caption{Memory virtualization architecture.}
	\label{fig:}
\end{figure}

\section{Task Coalescing}
\label{sec:memory_virtulaization}

\begin{figure}
	\centering
	%\includegraphics[width=0.25\columnwidth]{figures/}
	\caption{Task coalescing architecture.}
	\label{fig:}
\end{figure}

\section{Discussion}
\label{sec:discussion}

\section{Methodology and Evaluation}
\label{sec:methodology_evaluation}

\section{Related Work}
\label{sec:related_work}

\section{Conclusions}
\label{sec:conclusions}

This paper presented \sys: \sysfull.

%%%%%

\section{Old Introduction}
	Intermittently powered devices (IPDs) are battery-less devices that utilize the ambient energy to sense, compute and, communicate. For example, Wireless Identification and Sensing platform WISP \cite{wisp} uses the RF signal power to drive its computation and communication. Because of the reliance of TPDs on intermittent power supply, the harvested energy when it is available, their programs are susceptible to a very frequent power interrupts, in the order of tens of millisconds~\cite{}. Therefore, these devices require a different software execution model that complies with the nature of a discontinuous power supply. 

	The intermittent (discontinuous) execution model defines a program execution as cumulative discrete process. The main difference between the intermittent and the conventional (or continuous) execution models is that, a power failure is seen by the continuous model as an \emph{exception} that may reset the progress of a program to its beginning. Whereas, in intermittent execution a power failure is regarded as a temporary \emph{pause} to the execution that may result in some progress degradation. Generally we can classify the intermittent execution model into: 
	\begin{itemize}
		\item \emph{Sequential Execution Model}:
			Under this model a program is seen as one big idempotent operational region that has one common context. Generally, The progress of the program is saved and updated by means of checkpointing---where all the program context (e.g. CPU registers, the stack and the global variables) is saved to a non-volatile memory. Normally, the sequential model relies on a hardware assistant to measure the voltage level in the energy reservoir to place a checkpoint~\cite{mementos, harvOS, hibernus}. The benefit of this model is that it does not require code modification by a programmer. However, it has a number of drawbacks: (i) It suffers from significant overhead \cite{chain}; (ii) the programmer should not access the non-volatile memory to guarantee the consistency of the memory~\cite{xxxx}; and (iii) it restricts the IPDs to run only a single application~\cite{inos}. 
		\item \emph{Modular Intermittent Execution Model}:
			At the heart of this model is the concept of an idempotent task. The idempotent task is C function that does not have arguments and does not return a value. This task uses a well defined interface to interact with the non-volatile memory. Therefore, it tolerates arbitrary number of power interrupts. This model, generally, produces less overhead~\cite{chain} and allows multiple applications to run on an IPD by interleaving their tasks~\cite{inos}. However, it obviously requires code modification---for example, if an algorithm is written according to the continuous execution model it has to be splitted, by a programmer, into small tasks to run under the modular intermittent execution model.
	\end{itemize}

Despite that the superiority of the Modular Intermittent Execution model, it is still a static approach that completely depends on a programmer's estimation which is mostly result in a sub-optimal code devision. Moreover, this model can only consider a single hardware configuration and it does not take environment changing into considerations. 




% Energy source


% The intermittent execution is cumulative discrete process. The intermittent execution model is only able to execute a few number of instructions, as compared to the conventional (continuous) model, before its progress is terminated. Therefore, the intermittent execution model adapts an execution progress state saving mechanism. This mechanism is realized either by means of a checkpoint~\cite{}, where all the context of the program is saved into non-volatile memory. Or 

% This progress state saving mechanism is normally injected into a program either by a compiler~\cite{}. A compiler injects trigger pointers to checkpoint (save) the context of the program into the non-volatile memory.  or it is added by a programmer~\cite{chain}. [compare these two approaches]...

% We define virtualization within the context of intermittent execution as utilizing the volatile memory instead of non-volatile when the intermittent execution model attempts to access the non-volatile memory. 

\subsection{Why not Adapting Current Approaches}
Here we highlight the challenges of adapting the state-of-the-art proposed methods to enable the execution of dynamic task sizes. 
%
%	\begin{figure}[t]
%	    \centering
%	         \subfigure[Chain: Sequential task execution flow control.]{\includegraphics[width=0.35\columnwidth]{figures/dynamic-chain.pdf} \label{fig:DynamicChainSeq} } 
%	         \subfigure[Chain: Random task execution flow control.]{\includegraphics[width=0.61\columnwidth]{figures/dynamic-chain-2.pdf} \label{fig:DynamicChainRan}}
%	    \caption{Task flow control of Chain}
%	    \label{fig:DynamicChain}
%	\end{figure}


\noindent\textbf{Chain: Tasks and Channels for Reliable Intermittent Programs } \\
Some of the main problems in modifying Chain to support dynamic task's size are:

\begin{itemize}
	\item \emph{Multi-versioning system:} Chain defines for each task its own input that is not shared with other tasks. This design decision makes the benefit of merging tasks of less importance since each task is interacting with its own variables. 
	\item \emph{Direct FRAM system:} Chain tasks directly access FRAM which is more energy expensive Than SRAM. As result of being multi-versioning system that directly interacts with FRAM, Chain has a significant energy consumption overhead. 
	\item \emph{Irreversible tasks transitions:} According to the Chain programming model, each task calls the next one. The transition is done through functions calls and manually clearing the stack, to prevent the stack overflow problem. This approach make all the transitions firm ones which prevent task merging.
	\item \emph{All channels are required:} Fig.~\ref{fig:DynamicChainSeq} shows that if the task control flow is a circular with no branches then task merging is possible. Moreover, all the intra-merged-tasks channel can be committed to SRAM instead of FRAM to save energy. However, this execution path is only a special. If the general case (see Fig.~\ref{fig:DynamicChainRan}) is considered then leaving out the intra-merged-task channels might result in data inconsistency---If an application tries to access a merged task from the middle after a power interrupt then the input for that task is not ready which result in an incorrect execution. 


\end{itemize}


\noindent\textbf{Alpaca: Intermittent Execution without Checkpoints} \\
Some of the main problems in modifying Alpaca to support dynamic task's size are:

\begin{itemize}
	\item \emph{Privatization:} The core concept of Alpaca is privatization. Privatization depends completely on detecting the variables that have a Write-after-read dependency within the scope of a task. Therefore, if tasks are on-demand merged the scope of these dependencies are changed and the static analysis to privatize these variables is not valid anymore and data consistency can not be preserved.  

	\item \emph{Irreversible tasks transitions:} Similar to Chain problem. 

\end{itemize}

\noindent\textbf{Virtualizing Modular Intermittent Execution Model}

		An Intermittently executed program, as seen by the modular intermittent execution model, is a chain of tasks with a firm transition from one to another. 
		Virtualizing this model means softening a number of transitions, by keeping the state of the execution progress in the volatile memory, to construct a bigger \emph{virtual task} to reduce energy consumption. Ideally, the size of the virtual task should match the length of a continuous interval of the intermittent power supply for the best performance. Another form of virtualization can be achieved by reducing the number of non-volatile memory accesses. This can be done by having a temporary copy of a global variable in the volatile memory (similar to the catching principle) and a task interacts with it and updates it before writing back the most recent value to the non-volatile memory during the commit process.

		In this paper we are introducing VIPOS a runtime library the implement the Virtualed Intermittent Execution Model. VIPOS adapts two methods for data protection. One relies on a virtual buffer and the other uses the Direct Memory Access (DMA). VIPOS is able to approach the optimal tasks devision during the runtime. VIPOS reduces an application execution time by XX and the energy by XX. 


\subsection{Contributions}
	 \begin{enumerate}
		 \item We have developed an algorithm that is able to determine the size of a virtual task based on the history of the execution of an application. 
		 \item We enable efficient code portability by requiring that a real task to small and merging them during the execution.   
	\end{enumerate}


 \section{Preliminary Results}
 \label{sec:prelResults}

\begin{figure}[t]
    \centering
         \subfigure[The energy cost of FRAM/SRAM \textbf{writes} operations.]{\includegraphics[width=0.48\columnwidth]{figures/fram_write.eps} }
         \subfigure[The energy cost of FRAM/SRAM \textbf{read} operations.]{\includegraphics[width=0.48\columnwidth]{figures/fram_read.eps}}
    \caption{The energy cost of accessing volatile/non-volatile memory}
    \label{fig:framEnergy}
\end{figure}

Since the Intermittent execution models rely on the non-volatile memory to enable long-running operation, it is important to characterize the energy consumption of accessing this type of memory as compare to the volatile one.

Four applications are developed to measure the energy consumption of \emph{Accessing} the FRAM and SRAM of the MSP430FR5969 microcontroller~\cite{xxx}. The interference free debugger (EDB)~\cite{xxx} is used as the energy measurement tool. The EDB probes the energy buffer before and after accessing the FRAM/SRAM 1600 times, This large number of FRAM access is used to increase the reliability of the results generated by the used measurement tool (e.g. reducing the effect of the quantization error).  The energy buffer is charged, using the EDB, to $\approx$ 2.45 volts \textbf{only} at the beginning of the execution and of the programs. The write operations were performed by writing literal values, random numbers, to the memory. However, a read operation must be followed by a write operation, therefore, we chose to write a read value to SRAM. Fig.~\ref{fig:framEnergy} shows that an FRAM access equals $\frac{3}{2}$ SRAM access~\footnote{We would like to mentioned that TI has already mentioned in this document~\cite{xxxx} that FRAM write access is more energy expensive than SRAM write access. However, TI does not quantify the energy overhead.}. Therefore, reducing FRAM access is desirable when developing  energy limited software solution  




\section{VIPOS: Virtualized Intermittently Powered Runtime Environment}
VIPOS is runtime library that facilitates tasks navigation and preserves data/memory consistency of the IPDs. It is able, on-demand, to merge tasks to reduce the number of commits to the non-volatile memory.

\input{iposDataProtection}

\subsection{VIPOS: The Virtualizing Engine}
\subsubsection{Power Interrupt Immune Scheduler}
It utilizes a persistent circular buffer (persistent linked-list) to keep the state of a program across power failures. VIPOS provides an API to enable a programmer to have a full control over the execution flow of the program, i.e. (un)blocking a task or re-execute the same task which is particularly important in the intermittent execution to emulate a persistent loop. 

\subsubsection{Task Merging Algorithms}

\paragraph{Fixed Virtual Task Size} [better name needed]

	\begin{algorithm}[t]
		\caption{Fixed virtual Task size}
		\label{algo:fixVirtTask}
		\scriptsize
		%\small
		\begin{algorithmic}[1]
			\State $VT \subset \text{\{VIPOS Tasks\}} $  \Comment{$VT:$ Virtual Task}
			\State VTS : VT size
			\State MVTS: maximum VT size
			\vspace{0.1cm}

			\While {$True$}
				\State $VT \leftarrow VT_{next}$
				\vspace{0.1cm}
				\While {execute $VT$} 
					\If { $\text{power failed twice}$ }				
							\State $VTS--$  
							\State $ MVTS = VTS $
						\EndIf
				\EndWhile

				\vspace{0.1cm}
				\If {$ \text{All tasks executed}$}
					\If{$VTS < MVTS$}
					\State $VTS++$
					\EndIf
				\EndIf
			\EndWhile
		\end{algorithmic}
	\end{algorithm}


	\begin{algorithm}[t]
		\caption{Opportunistic virtual Task size}
		\label{algo:fixVirtTask}
		\scriptsize
		%\small
		\begin{algorithmic}[1]
			\State $VT \subset \text{\{VIPOS Tasks\}} $  \Comment{$VT:$ Virtual Task}
			\State VTS : VT size
			\vspace{0.1cm}

			\While {$True$}
				\State $VT \leftarrow VT_{next}$
				\vspace{0.1cm}
				\While {execute $VT$} 
					\If { $\text{power failed twice}$ }				
							\State $VTS--$  
						\EndIf
				\EndWhile

				\vspace{0.1cm}
				\If {$ \text{All tasks executed}$}
					\State $VTS++$
				\EndIf
			\EndWhile
		\end{algorithmic}
	\end{algorithm}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/virtualTaskSize.eps}
	\caption{Size of the virtual task versus the execution time of a dummy application that contains 12 empty tasks.}
	\label{fig:virtualTaskSize}
\end{figure}

VIPOS is able to virtually merge tasks to construct a bigger virtual task and commit the state of the virtual task instead of the individual real tasks. 
Fig.~\ref{fig:virtualTaskSize} show the benefit of virtualizing the Modular Intermittent Execution Mode (MIEM) in the best case scenario (continuous power supply). 

Remark: A less obvious benefit of visualization is that it can enable a secure computation. By increasing the size of the virtual task, the energy in the super-capacitor will not be enough to finish the execution of the virtual task. Therefore, without the interrogator being close to the intermittently powered device and charging rate is not negligible as compared to the discharging rate this computation will not be finished. As such, virtualization can add a layer of security to the computation.

\section{Results}
We compare the performance of VIPOS against a state-of-the-art intermittent execution approach. For this purpose, we used two different applications: (i) A data decompression application, which utilizes Huffman decoding technique to decompress 100 byte of data.; (ii) A discrete Fourier transform (DFT) application that uses two different resolution (4 and 8 bites) to analyze a randomly generated signal. 

\subsection{Continuous Power Supply}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/ipos_chain}
	\caption{Time to complation of VIPOS versus Chain. Decomp: Data decompression application. DFTx: Discrete Fourier Transform.}
	\label{fig:IPOSPerformance}
\end{figure}

Fig.~\ref{fig:IPOSPerformance} shows that VIPOS requires a shorter execution time to execute an application under the MIEM. The size of the virtual task that VIPOS uses equals One real task, in other words, no visualization is applied.



\subsection{Intermittent Power Supply}
...

\bibliographystyle{abbrvnat}
\bibliography{bib}

\end{document}
