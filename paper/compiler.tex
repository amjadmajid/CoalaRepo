\sys additionally provides a compiler support for automatic task generation, eliminating programmer's burden of writing a task-based program from scratch. The compiler gets a plain-C code as an input and generates a binary that is rewritten in task-based programming style that can run on \sys without additional programming effort. Automatic task generation compiler is often inefficient than human-written code for \sys because if unbounded loop or pointer is present, the compiler makes a conservative decision. \emph{If the performance is critical, the programmer may want to manually write the task-based code by himself. Otherwise, the programmer can rely on the compiler for simplicity.}

The compiler consists of two part: analysis pass and transform pass. Analysis pass analyze the code structure and decides where to put task boundaries. Transform pass converts the code into task-style program and pepper it with necessary \sys keywords so that it can run on \sys system. It is implemented using LLVM.

\subsection{Analysis Pass}
\label{sec:analysis}

\sys compiler decides the task size based on the number of LLVM IR instructions.
That is, it tries to make every task to contain roughly the same amount of LLVM IR
instructions. Intuitively, the number of LLVM IR instructions have a correlation with
the total workload done by the task. However, the number of LLVM IR instructions is 
a crude approach of estimating workload of a task since actual machine instructions are
what count and it is not exactly the same as LLVM IR instruction. Also, different instructions
have different power usage, use different cycles, etc. However, the size of each
task need not be exactly the same and it is sufficient to make sure that all of the
tasks are small enough to fit in to the energy budget. Counting LLVM IR instruction is sufficient
in this perspective.

\sys compiler first builds a CFG graph where each basic block is a vertice and branch
from one basic block to another is a unidirectional edge. Each vertices has a
{\em price}, which is the number of LLVM IR inside the vertice. 
When forming a task, each task should contain a basic block so that the sum of price of the 
blocks within each tasks should be roughly the same. Price makes the workload done by
each tasks roughly the same and make no task exceed the energy bound.

Each edge has a {\em penalty}, which indicates the penalty of placing a task boundary at
the specific edge. Intuitively, when a task boundary is placed on a frequently visited edge
(such as a back edge of a loop) the system suffers from higher runtime overhead.
There is no way of statically estimating the number of visit of each edges, so we initally set every
edge penalty as 1. When analyzing loops, penalty of edges within loops are multiplied by loop count.
\todo{Change the penalty to be 1 or 1*loopcount}{Kiwan}

Ater constructing a graph and assigning price and penalty, the compiler analyzes loops. 

except those inside a loop which is set as the loop count. Unbounded loops are conservatively considered very large.







\subsection{Transform Pass}
\label{sec:transform}
