{\noindent \textbf{Intermittently-Powered Devices:}} There is a large body of research on energy harvesting and wirelessly powered embedded devices. Several recent reviews provide a broad in-depth overview~\cite{prasad_comst_2014,sample_procieee_2013,huang:commag:2015,visser_procieee_2013,kamalinejad_commag_2015,ku_cst_2016}. As computing power consumption continues to decrease, a new wave of {\em ambiently} powered systems is emerging, powered by e.g. radio waves~\cite{patel_pervasive_2017,rf_powered_computing_gollakota_2014}.
Radio-powered devices~\cite{wisp5,moo,zhao_rfid_2015,holleman_biocas_2008,thomas_jbcs_2012,naderiparizi_rfid_2015,rodriguez_tbcs_2015,liu_sigcomm_2013,kicksat,nadeau_naturebio_2017}
are related to \sys---they are the technological foundation of an
important category of intermittent computing devices. The emergence of
intermittent computing hardware platforms has led to the development of tooling
and instrumentation for such systems
building~\cite{hester_sensys_2014,hester_sensys_2015,edb,stork,wisent}.

{\noindent \textbf{Intermittent Execution Environments:}} Early work on Energy-harvesting runtime systems assumed simple, small computations not exceeding a predictable burst of energy~\cite{dewdrop} or long power-cycles/priority-based scheduling~\cite{sorber_sensys_2007}. These efforts did not consider data consistency with intermittence. Works supporting intermittent computing using dynamic, on-demand checkpoints for consistency include Mementos~\cite{mementos}, Quickrecall~\cite{quickrecall}, Hibernus++~\cite{hibernusplusplus} and HarvOS~\cite{mottola2017harvos}. Dynamic checkpointing systems may checkpoint
at any point, making it difficult to implement application-level atomicity
requirements. Moreover, some systems require hardware to measure stored energy, incurring energy cost. Moreover, these systems do not checkpoint non-volatile state, compromising memory consistency. DINO~\cite{dino} selectively versions non-volatile memory and checkpoints volatile state, ensuring progress and memory consistency. Rachet~\cite{ratchet} assumes all memory is non-volatile and checkpoints volatile state. Clang~\cite{hicks_isca_2017} takes a Ratchet-like approach leveraging special hardware, eliminating checkpointing and versioning overhead. 

Recent task-based systems are Chain~\cite{chain} and
Alpaca~\cite{alpaca}. Using static tasks, they eliminate checkpointing volatile state. Using channel-based memory models~\cite{chain} or automatic privatization and redo-logging~\cite{alpaca} they avoid checkpointing overheads. Moreover, task-based models facilitate specifying application-level atomicity properties.

\sys relates to the above efforts but is distinct in approach and mechanism. \sys relates closely to task-based models because \sys also relies on statically defined tasks to avoid checkpointing volatile state. \sys's automatic compilation spares the programmer's work of writing task-based code that prior systems demand. \sys's memory virtualization provides an alternative for ensuring memory consistency, optimized for bulk accesses to task-shared data with high locality. \sys's task coalescing optimization ameliorates the key overheads associated with prior systems.

{{\noindent \bf Memory Virtualization:}} Prior work on embedded systems has studied a variety of memory virtualization strategies that relate to \sys. TinyOS~\cite{levis2005tinyos} and nesC~\cite{nesc} support dynamic memory management. Later work extended the memory manager to support memory virtualization backed by flash memory~\cite{sensornetvm} and to ensure memory and type safety~\cite{tinyosmemorysafety}. SOS~\cite{sos}, Contiki~\cite{contiki}, and
t-kernel~\cite{tkernel} also developed memory management abstractions that
virtualize memory size and provide safe and indirect access. Mat\'e~\cite{mate} developed full virtual machines support for sensor nodes, virtualizing not just memory resources, but other states and peripherals. The goal of \sys is to provide consistent, intermittent execution, leveraging the benefits of efficient bulk copying. In contrast, these prior efforts were focused more on programmability and runtime reliability properties provided by virtual memory.

Another \sys-related prior effort is on unbounded, page-based transactional memory and deterministic parallel runtime systems~\cite{pagebasedtm,grace}. These works have a different mechanism and purpose than \sys---ensuring that data are consistent and
deterministically updated during concurrent executions. What makes these
efforts related is that they manage state to ensure consistency at the
granularity of pages to amortize checking and tracking costs. \sys also tracks
accesses at the granularity of a page and uses its paging mechanism to ensure
consistency. Moreover, \sys's paging implementation, which keeps a shadow page
for each page to use during commit, is similar to the shadow paging scheme
use for transactional commit~\cite{pagebasedtm}.