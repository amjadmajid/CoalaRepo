We implemented \sys's programming and execution model as a runtime library and API that a programmer can use to make a plain C program intermittence-safe.
%
\subsection{Application Programming Interface}
\label{sec:coala_api}
%
Coala's API adds only eight syntactic constructs to a C-based language, summarized
in Table~\ref{table:coala_api}.
%
\begin{table}
\centering
\begin{tabular}{| r | p{0.67\columnwidth} |}
	\hline
	{Method} & {Arguments} \\
	\hline\hline
	\texttt{INIT}($t$) & $t \in \mathbf{T}$: scheduled task on first boot \\
	\hline
	\texttt{RUN}() & --- \\
	\hline
	\texttt{TASK}($t$, $w_t$) & $t \in \mathbf{T}$: task name, $w_t$: weight of task $t$ \\
	\hline
	\texttt{NEXT\_TASK}($t$) & $t \in \mathbf{T}$ : task to be run next \\
	\hline
	\texttt{PV}($p$, $v$ [, $s$]) & $p$: variable type, $v \in \mathbf{V}$: new protected variable name, $s$: array size \\
	\hline
	$u$ := \texttt{RP}($v$) & $v \in \mathbf{V}$: protected variable to be read, $u$: destination operand \\
	\hline	
	\texttt{WP}($v$) := $u$ &  $v \in \mathbf{V}$: protected variable to be written, $u$: source operand \\
	\hline
	\texttt{SM}($p$, $m$ [, $s$]) & $p$: \texttt{struct} member's type, $m$: \texttt{struct} member's name, $s$: array size \\
	\hline
\end{tabular}
\caption{API summary; $\mathbf{T}$: set of all tasks, $\mathbf{V}$: set of all protected variables, $[, s]$: optional argument.}
\label{table:coala_api}
\end{table}
%
\noindent\textbf{New Tasks.} The \texttt{TASK} annotation on a function
declaration statically allocates a non-volatile constant variable holding a
task's weight and declares that the function is a task.\\
%
\noindent\textbf{Task Transitions.} A call to \texttt{NEXT\_TASK} marks the task to be executed at the 
end of the current one task and it can be invoked along
any control path to dynamically determine the next task.\\
%
\noindent\textbf{Protected Variables.} The \texttt{PV} annotation on a
variable statically allocates a protected non-volatile variable. The
variable must then be accessed with the \texttt{RP} and \texttt{WP} API methods at
runtime to ensure correct operation.\\
%
\noindent\textbf{Initialization.} The behavior of the API method
\texttt{INIT} is very similar to \texttt{NEXT\_TASK}, with the
addition of performing preliminary kernel initializations, including hardware setup.\\
%
\noindent\textbf{Execution.} The programmer passes control to \sys's task scheduler 
by calling \texttt{RUN} after device initialization. 
%
First the scheduler updates the coalescing target using the coalescing
strategy.  Second, the scheduler resumes a commit, if one is in progress. Third,
the scheduler clears the list of dirty shadow pages. The scheduler then 
sets the program counter to the next task to run, which \sys tracks in  
non-volatile memory.  
%
Before executing the task, \sys checks whether there is a partially committed
task to resume, which requires \sys to restore volatile state, including the program
counter.  
%
If there is no in-progress, partially committed task, \sys starts executing and
coalescing tasks. 


\subsection{Paging}
\label{sec:impl:paging}

As described in Section~\ref{sec:memory_virtulaization}, \sys's memory
virtualization scheme uses three buffers: a volatile \texttt{working} buffer, a
non-volatile \texttt{\underline{private}}, and a non-volatile
\texttt{\underline{shadow}} buffer. 
%
The main memory \texttt{\underline{private}} holds the last committed copy of all 
pages. 
%
After reboot, the \texttt{working} buffer is empty. Execution fills 
the \texttt{working} buffer with privatized pages as the program accesses them. 
%
The \texttt{\underline{shadow}} buffer serves as an intermediate,
non-volatile backing \texttt{\underline{private}} for dirty pages evicted from the space-constrained
\texttt{working} buffer. 

To access a protected variable with either \texttt{RP}
or \texttt{WP}, \sys searches for the variable in its \texttt{working} buffer first.
 If the page is not, the VMM fetches it from non-volatile memory. 
%
\sys uses address-based page tagging to make finding a variable efficient.  The
upper bits of a variable's memory address identify its page, and the lower bits
denote the variable's offset in its page. The total number of pages in memory,
$p$, determines the number of tag bits, which is $\log P$.

Page tagging imposes a data alignment requirement.
Page size $S$ must be a power of two. 
%
Pages must be aligned to an $S$-byte boundary for efficient memory access. 
%
We experimented with 32-, 64-, 128- and 256\,B pages, an 8\,KB non-volatile \texttt{\underline{shadow}} buffer and
an 8\,KB non-volatile \texttt{\underline{private}}, and a \texttt{working} buffer
of 1\,KB.
%
\subsection{Coalescing and Commit}
%
The coalescing algorithm starts with a random guess about the size of the coalescing task, in our implementation the target is initialized to four. It then refines its guess based on the number of the static-tasks being successfully executed.
%
When a coalesced task completes, \sys save all the modifications in its \texttt{\underline{private}} using DMA. In order to ensure the atomicity of the commit operation all the modified pages are copied to the \texttt{\underline{shadow}} buffer first. The \sys set a flag to indicates an on-going \emph{atomic commit} to update the private pages. For efficiency reasons \sys uses an indirection table to point to the private consistent pages and eliminate the need for moving pages for the second time.
%
\subsection{Task Downscaling}
%
\sys's task downscaling preserves forward progress by partially committing an
ongoing, non-terminating task. 
%
Partial commit relies on the existence of a hardware timer, which is a very
common feature in a typical MCU and consumes very little energy (i.e.,
$\approx$3\,$\mu$A/MHz~\cite{msp430datasheet}).  

 \textbf{Partial Commit and Task Atomicity.} Some applications prevent
downscaling a task because of a need for task atomicity.  For example, sampling
an analog signal requires consecutive samples at a known interval, or the
digitally sampled signal is meaningless.  In such a case, the programmer can
disable partial commit for a task or a span of code, marking  the code with a
pair of \texttt{DISABLE\_PE} and \texttt{ENABLE\_PE} annotations.
These annotations respectively halt and resume the partial execution timer.