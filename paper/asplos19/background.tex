\subsection{Energy Harvesting Systems}
\label{sec:background_harvesting}

Energy harvesting devices operate using energy extracted from sources such as
radio frequency transmissions and solar energy. These devices elide tethered
power or a battery, instead collecting energy into a capacitor, operating when
sufficient energy accumulates, and upon depleting the energy, turning off and
recharging.
%
%Batteryless operation has a number of important advantages, making intermittent computing an important research domain. Supplying power to billions~\cite{gartner_iot} of embedded computers using batteries is not sustainable. The European Commission estimates that more than 160 kilotons of consumer batteries enter the European Union annually~\cite{eu_batteries_2016}. Batteries are an environmental risk, are fragile, are limited in their number of charge/discharge cycles, and may require costly physical maintenance that is difficult or impossible deployed (e.g. in space~\cite{kicksat}). By contrast, super-capacitors are durable, promising millions of charge/discharge cycles~\cite[Sec. I]{ongaro_pwre_2012}. The main limitation in moving to capacitor-based energy storage is that capacitor energy density---and consequently operating discharge time---is orders of magnitude less than a battery. 
%
%Given current technology development, battery-less systems are best suited for very long-term sensing and monitoring where access to recharge is either prohibitive or impossible. These include battery-less image capture and processing~\cite{naderiparizi_rfid_2015}, animal monitoring~\cite{thomas_jbcs_2012} or implantable~\cite{rodriguez_tbcs_2015} and digestible~\cite{nadeau_naturebio_2017} sensors.
%
There are several energy harvesting battery-less hardware platforms. For
instance, computational RFIDs---open-source TI MSP430-based~\cite{wolverine}
WISP~\cite{wisp5} (with its variants such as
WISPCam~\cite{naderiparizi_rfid_2015}, NFC-WISP~\cite{zhao_rfid_2015} or
NeuralWISP~\cite{holleman_biocas_2008}), Moo~\cite{moo}, and commercial ones
such as~\cite{medusa_farsens_2017}. Other platforms include ambient backscatter
tag~\cite{liu_sigcomm_2013,parks_sigcomm_2014} or battery-less
phone~\cite{talla_imwut_2017}. 

%In all of the above, the main source of energy harvested is the electromagnetic radiation in the radio frequency range (ambient transmitters such as high power TV transmitters~\cite{liu_sigcomm_2013} or dedicated RFID antenna~\cite{wisp5,moo,talla_imwut_2017,medusa_farsens_2017,holleman_biocas_2008,naderiparizi_rfid_2015}). Naturally, other forms of energy harvesting sources exist, including temperature gradient, (micro-)motions, light/sun radiation, vibrations, and body fluid flow (blood, gastric acid). Several recent surveys discussing energy harvesting, low-power, embedded systems and intermittent computing at a high level~\cite{paradiso_pvc_2005,soyata_csm_2016,prasad_comst_2014,ku_cst_2016,lucia_snapl_2017}.

\textbf{Hardware Assumptions.} \sys is designed for the demands of existing and
future energy-harvesting platforms based around general purpose, commodity
computing components~\cite{wisp,msp430datasheet}. We assume a device with a
memory system that has fast, byte-addressable volatile and non-volatile memory;
in particular, our target platform, WISP~\cite{wisp}, is equipped with a
mixture of SRAM and FRAM. Our implementation leverages hardware support for
fast, bulk-copying between memories via DMA~\cite{msp430datasheet}. \sys does not
require architectural additions to commodity processors as
in~\cite{su_date_2017,hicks_isca_2017,quickrecall,nvp}.

\subsection{Intermittent Execution}
\label{sec:background_consistency}

% \begin{wrapfigure}{t!}{0.5\textwidth}
\begin{figure}
	\begin{subfigure}[t]{\linewidth}
		\centering \includegraphics[width=\columnwidth]{figures/crc_example}
		\caption{Simplified C code snippet of a CRC calculation from~\cite{hicks_mibench2_2016}: per-byte message division by a polynomial; \texttt{NV} denotes non-volatile variable declaration.}\label{fig:crc_example}
	\end{subfigure}
	\begin{subfigure}[t]{\linewidth}
		\centering \includegraphics[width=\columnwidth]{figures/crc_example_war}
		\caption{Execution steps of the loop body in the snippet above: non-volatile checkpointing did not guarantee data consistency as data has been manipulated (line 9) with stale reminder (line 3)}\label{fig:crc_example_war}
	\end{subfigure}
	\caption{Code example demonstrating checkpointing gives rise to data inconsistency.}\label{fig:code_demo_incosistency}
% \end{wrapfigure}
\end{figure}

Software running on an energy-harvesting device executes {\em intermittently}
because energy sources are not always available to harvest and buffer
sufficient operational energy. An intermittent execution is composed of
operating periods interspersed with power
failures~\cite{dino,chain,alpaca,ratchet}. The frequency of failures depends on
the size of the device's energy storage buffer: a larger buffer allows longer
operating periods. 
%Energy-harvesters provide input power orders of magnitude less than operating power, making recharging negligible during operation.
%Intermittent execution is different from continuous execution. 
A power failure clears volatile state (e.g., registers and SRAM) while
non-volatile memory (e.g., FRAM) persists. Upon a power failure, control flows
to a prior point in the execution: by default, to the beginning of {\tt
main()}. Early intermittent systems preserved progress by periodically
checkpointing volatile execution context to non-volatile
memory~\cite{mementos}, sometimes using hardware
support~\cite{mottola2017harvos,hibernusplusplus,hibernus,idetic,quickrecall}. 

%\begin{figure}
%	\centering
%	\subfloat[Simplified C code snippet of a CRC calculation from~\cite{hicks_mibench2_2016}: per-byte message division by a polynomial; \texttt{NV} denotes non-volatile variable declaration]{\includegraphics[width=\columnwidth]{figures/crc_example}\label{fig:crc_example}}\\
%	\subfloat[Consecutive execution steps of the loop body in the snippet above: non-volatile checkpointing did not guarantee data consistency as data has been manipulated (line 9) with stale reminder (line 3)]{\includegraphics[width=\columnwidth]{figures/crc_example_war}\label{fig:crc_example_war}}
%	\caption{Code example demonstrating effect of write after read on volatile memory checkpointing.}
%	\label{fig:code_demo_incosistency}
%\end{figure}

Checkpointing volatile state alone do not ensure data consistency when the
system can directly manipulate non-volatile memory~\cite{mspcdino}.
Especially, data can get inconsistent when code includes a
\emph{write-after-read} (WAR) dependence between operations that manipulate
non-volatile memory, because it allows {\em writes} from a failed attempt to
persist across failure and be read by the {\em
reads}~\cite{ratchet,dino,alpaca}\TODO{figure 2 dependent text ---see
Figure~\ref{fig:code_demo_incosistency} that illustrates how state can become
inconsistent in an intermittent execution using the cyclic redundancy check
(CRC) code from MIBench2~\cite{hicks_mibench2_2016}.  Additional method to
maintain data consistent in the presence of WAR dependency is necessary for
correct execution.}
%Checkpoints of volatile state preserve intermittent progress, but do not ensure data consistency~\cite{dino,chain,ratchet}. Data may become inconsistent if an attempt to execute some computation {\em writes} to a non-volatile variable, then power fails, then a second attempt to re-execute the same computation incorrectly {\em reads} the value written in the first attempt, rather than the variable's original value. The situation occurs when code includes a \emph{write-after-read} (WAR) dependence between operations that manipulate non-volatile variables~\cite{ratchet,dino,alpaca}---see Figure~\ref{fig:code_demo_incosistency} that illustrates how state can become inconsistent in an intermittent execution using the cyclic redundancy check (CRC) code from MIBench2~\cite{hicks_mibench2_2016}.
%Figure~\ref{fig:code_demo_incosistency} illgit statuustrates how state can become inconsistent in an intermittent execution using the cyclic redundancy check (CRC) code from MIBench2~\cite{hicks_mibench2_2016}. The code computes the CRC for an $\texttt{nBytes}$ byte message $\texttt{msg}$ with remainder $\texttt{Rmnd}$.
%Despite checkpointing at line 3 in Fig.~\ref{fig:crc_example}, the code may compute  $\texttt{data}$ incorrectly because of the read of $\texttt{Rmnd}$ on line 4 and the write of $\texttt{Rmnd}$ on line 5. Figure~\ref{fig:crc_example_war} shows an intermittent execution. The second iteration writes $\texttt{Rmnd}$, but power fails before the checkpoint. After restarting, line 9 reads the updated value of $\texttt{Rmnd}$, producing an incorrect $\texttt{data}$ value. Checkpoint-based systems risk violating memory consistency~\cite{dino}. 
%To maintain consistency, prior systems~\cite{dino} {\em version} a subset of non-volatile data with the checkpoint. Task-based systems~\cite{chain,alpaca}, which we focus on, ensure consistency using programmer, compiler, and runtime support.


\subsection{Task-based Intermittent Programming}
\label{section:background_task_computing}

Task-based execution models~\cite{dino,chain,alpaca} ask the programmer to
decompose their program into \textbf{tasks}, which is a region of code that can contain
arbitrary computation, sensing, and communication.  Task-based models progress at the granularity of tasks. They re-execute each task interrupted by a power failure until it successfully finishes, only then moving on to
the next task. Since these models do not rely on taking an expensive
checkpoint, they are usually faster than the checkpoint-based
solution~\cite{chain, alpaca}.  \sys also follows the paradigm of the
task-based programming model, where the programmer explicitly expresses the
application as a sequence of tasks and the transitions between them.

Task-based models also suffer from data inconsistency when there is a WAR
dependence.  Prior systems tried to tackle the problem by a compiler-automated
redo-logging for the variables that is part of the dependence~\cite{alpaca}, or
by statically creating multiple copies of the problematic variable to ensure
that no task reads and writes the same copy~\cite{chain}.
%There are several run time strategies to ensuring task idempotence. One approach~\cite{alpaca}, is to identify non-volatile data involved in WAR dependences in a task (like DINO~\cite{dino} and Ratchet~\cite{ratchet} did for checkpoints), execute the task using private copies of those data, and commit the private copies on task completion. Another way is to statically create multiple versions of non-volatile data shared by tasks and ensure that no task reads and writes the same version~\cite{chain}. Regardless of the strategy, task-based systems execute statically-defined tasks atomically, completing in one or more attempt. 

\subsection{Costs of Previous Models}
\label{sec:cost_task-based}

Prior systems, including the task-based models, suffer from two major overheads:
{\em frequent non-volatile memory access} and {\em incorrectly sized, inefficient or non-terminating tasks}.

\begin{table}
	\centering
	\footnotesize
	\begin{tabular}{|c|c|}
		\hline
		Model & Data Copied to/from NVRAM \\
		\hline\hline
		Mementos~\cite{mementos}	& Registers + Stack     \\
		DINO~\cite{dino}	& Registers + Stack + WAR NV variables \\%used in task\\
		Chain~\cite{chain}	& PC + NV variables used in task\\
		Alpaca~\cite{alpaca}	& PC + WAR NV variables used in task\\
		Ratchet~\cite{ratchet}, Clank~\cite{hicks_isca_2017} & Registers (requires NV main memory) \\
		Region Formation~\cite{baghsorkhi_cgo_2018} & Registers + Updated variables in task \\
		\hline
	\end{tabular}
	\caption{Non-volatile memory access for data consistency; \emph{PC}: program counter, \emph{WAR variables}: variables involved in Write after Read (WAR) dependences, \emph{NV}: non-volatile.}
	\label{table:chechpoint_comparison}
\end{table}


\textbf{Frequent Non-volatile Memory Access.} 
Previous systems frequently access the non-volatile memory directly, which is a potential source of inefficiency.  Checkpointing systems copy all volatile
state~\cite{dino, mementos, ratchet, hicks_isca_2017} to non-volatile memory at
every checkpoint.  Task-based models, which do not take checkpoints, back up a
subset of non-volatile data to maintain memory consistency using, e.g.,
redo-logging.  Table~\ref{table:chechpoint_comparison} summarizes the data that
gets copied to and from the non-volatile memory in service of memory
consistency and progress preservation.  Ratchet~\cite{ratchet} and
Clank~\cite{hicks_isca_2017}, which require all memory to be non-volatile
perform high-frequency non-volatile memory accesses, into checkpointing
frequently.

\textbf{Incorrectly Sized Tasks Problem.} Compiler-inserted checkpoints or
programmer-defined tasks can be both non-terminating and/or
inefficient.  If a task (or code between two checkpoints) consumes more than the fixed,
maximum energy that the device can buffer, then the task
will never be able to complete using buffered energy.  Such a task is
non-terminating, {\em prevents forward progress}, and makes the program
incorrect. 
%
If the task consumes far less energy than a device can buffer, the system
may operate {\em inefficiently}, saving the program state more often than needed.
%
Avoiding excessively costly, non-terminating, tasks and short, high-overhead,
tasks is challenging, because estimating the exact energy use of an arbitrary code is complicated.  
Moreover, when \emph{heterogeneous devices} with different energy buffers (e.g., 20\,$\mu $F~\cite{rodriguez_tbcs_2015} to 0.1\,F~\cite{moo}) are considered the problem of porting a program become much worse
because a large task on one device may be a relatively short task
on a device with a larger buffer.
%
\textbf{\sys's execution model} solves this dilemma by introducing {\em task coalescing}, which
merges multiple tasks to amortize the overhead when tasks are too small, and
{\em task downscaling}, which breaks up a task when the task is too large to complete. 
