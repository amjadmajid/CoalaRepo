\sys dynamically {\em coalesces} consecutively executing tasks at run time.
When two tasks are coalesced, the first of the two tasks does not commit its
updates to protected memory locations when it reaches a \transition statement.
Instead, execution immediately continues from the beginning of the second of
the two tasks.  At the end of the second of the two coalesced tasks, \sys
commits the pages that were updated by either of the coalescing tasks.  The
purpose of coalescing is to better amortize the run time overhead of committing
updated pages when a task ends. If consecutive tasks access the same pages of
data, the pages accessed by both tasks only need to be committed only once for
the coalesced task rather than twice, one time for each of the tasks executed
individually.  

\sys can coalesce an arbitrary number consecutive tasks.  As more tasks
coalesce, their collective commit overhead amortizes better, potentially
improving performance.  As more tasks coalesce, the amount of potentially {\em
wasted work} also increases. If power fails during a long sequence of coalesced
tasks the lack of an intervening commit requires execution to restart from the
{\em first} task in the sequence, failing to preserve the progress of any of
the tasks in the long sequence. 



\subsection{Task Coalescing Algorithm}

\begin{algorithm}[t]
	\caption{\sys task coalescing mechanism}
	\label{algo:coalescing}
	\scriptsize
	\begin{algorithmic}[1]
		\State $\text{p}$  \Comment{Indicates persistent variables, initialized \textbf{only} during device programming}
		\State $\text{RT} \in \{\sys~\text{static tasks}\}$  \Comment{Real task}
		\State $\text{VT} \subset \{~\text{RT's}\}$  \Comment{Virtual task}
		\State $\text{RTC}$  \Comment{RT counter}
		\State $\text{VTC}$  \Comment{VT counter}
		% \State $|\text{VT}|$ \Comment{VT size measured in RT}
		\State $\text{TVT}$ \Comment{Temporary VT}
		\State $\text{VT}_{\max}$ \Comment{Maximum VT size measured in RT (coalescing upper bound)}
		\vspace{0.1cm}
		
		\State $\text{p RTC} = x $ 
		\State $\text{p VT}_{\max} = y$
		\State $\text{p VT} = \text{RT}$ 
		\State $\text{p TVT} = \text{VT} $ 
		\State $\text{VTC} = 0 $ 
		\vspace{0.1cm}

		\Function{scheduler}{\null}

			\State $\text{VTC} = \text{RTC/2} $  \label{algo:coalescing:executionHistory1}
			\State $\text{RTC} = 0 $
			\State $\text{RT} = \text{VT}$ \Comment{Recover virtual state} \label{algo:coalescing:virtualProgressing1}
			\If{commiting}
				\State $\text{RT}=\text{TVT}$
				\State $\texttt{goto} \ \ \ref{commitStage}$ \label{algo:coalescing:firmTransition1}
			\EndIf
			\vspace{0.1cm}

			\While {True}
				\While{$\text{VTC}--$}
					\Function{execute}{$\text{RT}$}
					\EndFunction
					\If{$\text{RTC} < \text{VT}_{\max}$}
						\State $\text{RTC}++$  \label{algo:coalescing:realTaskCounter}
					\EndIf
					\State $\text{RT} \leftarrow \text{RT}_{next}$ \Comment{Virtual progressing}
				\EndWhile        \label{algo:coalescing:virtualProgressing2}

				\State \Comment{Virtual task is finished}
				\State $\text{Data} \rightarrow \text{pTempBuf}$ \Comment{pTempBuf: persistent temporary buffer}
				\State $\text{TVT} = \text{RT}$ 
				\State $\text{commiting} = \text{True}$ \label{algo:coalescing:firmTransition2}
				\State 
				\State $\text{VT} = \text{TVT}$ \label{commitStage}
				\State $\text{pTempBuf} \rightarrow \text{FRAM}$ 
				\State $\text{VTC} = \text{RTC/2}$ 		\Comment{Set VT size} \label{algo:coalescing:executionHistory2}
				\State $\text{commiting} = \text{False}$ 

			\EndWhile

		\EndFunction
			
	\end{algorithmic}
\end{algorithm}

\sys's coalescing algorithm uses a single point back in the \sys's execution
history to estimate the appropriate virtual task size. However, it takes a
conservative approach by making the virtual task size equal to the half of the
number of successfully executed real tasks before the last power interrupt (see
lines~\ref{algo:coalescing:executionHistory1},
\ref{algo:coalescing:executionHistory2} of Algorithm~\ref{algo:coalescing}). We
advocate for the algorithm conservative approach by the following two reasons:
(i) the power interrupts are not uniformly distributed over the tasks; and (ii)
the re-execution penalty, in case of a power interrupt, grows linearly with the
size of a virtual task. Furthermore, the algorithm considers the charging rate
by allowing the real tasks counter (RTC), which represents the execution
history between the last two power interrupts, to increase from one up to
multiple virtual tasks (see line~\ref{algo:coalescing:realTaskCounter} of
Algorithm~\ref{algo:coalescing}). As a consequence, the virtual task size
changes rapidly (since it is half of the execution history) in response to the
change in the charging rate. However, the algorithm sets a limit to the size of
the virtual task for these two reasons: (i) having an infinity virtual task
size, results in a certain computation progress loss; and (ii) the benefit of
task merging is governed by the diminishing return principle (which will be
demonstrated experimentally in Section~\ref{sec:results_coalescing}).

The algorithm protects itself from power interrupts by going into three stages: (i) virtual progressing, where the operations are done on the volatile memory (see lines~\ref{algo:coalescing:virtualProgressing1}--\ref{algo:coalescing:virtualProgressing2} of Algorithm~\ref{algo:coalescing} ); (ii) transition stage, where the volatile state is moved to a temporary persistent buffer. Until the end of the second stage if a power is interrupted, then all the virtual progress will be cancelled and the virtual task will re-executed and re-initialized from a consistent input (see line~\ref{algo:coalescing:virtualProgressing1} of Algorithm~\ref{algo:coalescing}); and (iii) persistent commit stage, upon entering this stage the algorithm will make a firm transition (see lines~\ref{algo:coalescing:firmTransition1}, \ref{algo:coalescing:firmTransition2} of Algorithm~\ref{algo:coalescing}) and it will not go back to the other stages unless all the data is committed from the persistent buffer to non-volatile memory. Since the data is being moved in one direction and from a persistent location, power interrupt is tolerable at this stage. 

\subsection{Power Interrupt Immune Scheduler}

\input{relativeJumpAlgo.tex} %Task jumping algorithm

It utilizes a persistent circular buffer (i.e. persistent linked list) to keep the state of a program across power failures. \sys provides an API to enable a programmer to have a full control over the execution flow of the program, i.e. (un)blocking a task or re-execute the same task which is particularly important in the intermittent execution to emulate a persistent loop. \todo{Expand this section}{Amjad}

%\begin{algorithm}
%	\caption{Opportunistic virtual Task size}
%	\label{algo:fixVirtTask}
%	\scriptsize
%	%\small
%	\begin{algorithmic}[1]
%		\State $VT \subset \text{\{\sys Tasks\}} $  \Comment{$VT:$ Virtual Task}
%		\State VTS : VT size
%		\vspace{0.1cm}
%		
%		\While {$True$}
%		\State $VT \leftarrow VT_{next}$
%		\vspace{0.1cm}
%		\While {execute $VT$} 
%		\If { $\text{power failed twice}$ }				
%		\State $VTS--$  
%		\EndIf
%		\EndWhile
%		
%		\vspace{0.1cm}
%		\If {$ \text{All tasks executed}$}
%		\State $VTS++$
%		\EndIf
%		\EndWhile
%	\end{algorithmic}
%\end{algorithm}
