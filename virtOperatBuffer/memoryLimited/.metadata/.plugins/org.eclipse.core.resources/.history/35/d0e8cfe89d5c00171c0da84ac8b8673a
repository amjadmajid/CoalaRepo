#include <operationalBuffer.h>

__nv volatile uint16_t __tbl_cntr =  0;
__nv volatile uint16_t __vtbl_flag =  0;  // if this is set then the buffer is not empty

/************************************
 a table of pointers to linkedlists
************************************/
uint16_t _indexTable[TEMPBUFSIZE_RAWS] = {{0}};   // _indexTable is used  to speedup the commit process
uint16_t tempVirtualBuf[TEMPBUFSIZE_RAWS][TEMPBUFSIZE_COLS] ={{0}};

// This can be a single pointer
__nv uint16_t tempPersistentBuf[TEMPBUFSIZE_RAWS][TEMPBUFSIZE_COLS] ={{0}};

/************************************
    initialize the index table
************************************/
void wb_initTable()
{
  uint16_t i ;
  for(i = 0; i < TEMPBUFSIZE_RAWS; i++ )
  {
      _indexTable[i]=0;
      if(_indexTable[i] == 0)
      {
          break;
      }
  }
}

/************************************
          hash function
************************************/
unsigned wb_hash(uint16_t * addr)
{
    return  (uint16_t) addr & TEMPBUFSIZE_RAWS;
}

/************************************
         wb_search function
************************************/
uint16_t wb_search(uint16_t * addr )
{
    // search the indexTable

    uint16_t i ;
    for(i = 0; i < TEMPBUFSIZE_RAWS; i++ )
    {
        if(_indexTable[i] == addr)
        {
            return i;
        }else if(_indexTable[i] == 0)
        {
            break;
        }
    }
    return TEMPBUFSIZE_RAWS+1 ; // invalid value
}

uint16_t __wb_returned_value = 0;
/************************************
        get the returned value
************************************/
uint16_t __wb_get_val(uint16_t * addr )
{
    return __wb_returned_value;
}


/************************************
        get function
************************************/
uint16_t wb_get(uint16_t * addr )
{
    wb_node * node = wb_search( addr );
    if(node != NULL)
    {
        __wb_returned_value = node->value;
        return 1;
    }
    return 0;
}

/************************************
        insert function
************************************/
void wb_insert(uint16_t * addr, uint16_t val)
{

      uint16_t hashVal = wb_hash(addr);
      tempVirtualBuf[ hashVal ][0] = addr ;
      tempVirtualBuf[ hashVal ][1] = val ;

      // TODO add the address to the _indexTable

}

/************************************
        First phase commit
************************************/

void wb_firstPhaseCommit(){
   __tbl_cntr = 0;    //initialize the counter for the next committing stage
   if(__vtbl_flag == 0 )
       {
           return;  // nothing to commit
       }

  uint16_t i, j=0;
  for( i=0; i < TABLESIZE; i++)
  {
    wb_node * np = _table[i];
    wb_node * np2 =NULL;
    while(np !=NULL)
    {
      tempPersistentBuf[j][0]= (uint16_t) np->addr;
      tempPersistentBuf[j][1]= np->value;
      j++;
      np2 = np->next;
      np = NULL;
      free(np);
      np =np2;
    }
  }
  __vtbl_flag = 0;  // First committing is finished
}

/************************************
        Second phase commit
************************************/

void wb_secondPhaseCommit()
{
  while(__tbl_cntr < TEMPBUFSIZE_RAWS)
  {
      if((uint16_t *) tempPersistentBuf[ __tbl_cntr ][0]  == NULL)
          return;

    *((uint16_t *) tempPersistentBuf[ __tbl_cntr ][0] ) = tempPersistentBuf[ __tbl_cntr ][1] ;
    tempPersistentBuf[ __tbl_cntr ][0] = 0;  // reset the address cell
    __tbl_cntr++;
  }
}
